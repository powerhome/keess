// endpoint_helpers_test.go
// package e2e_test

// import (
// 	"context"
// 	"fmt"

// 	. "github.com/onsi/gomega"
// 	"github.com/onsi/gomega/types"
// 	corev1 "k8s.io/api/core/v1"
// 	discoveryv1 "k8s.io/api/discovery/v1"
// 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
// 	"k8s.io/client-go/kubernetes"
// )

// // ServiceEndpointInfo represents endpoint information for a service
// type ServiceEndpointInfo struct {
// 	Addresses []string
// 	Ports     []discoveryv1.EndpointPort
// }

// // GetServiceEndpoints gets endpoint information for a service using EndpointSlices API
// func GetServiceEndpoints(client kubernetes.Interface, service *corev1.Service) ([]ServiceEndpointInfo, error) {
// 	endpointSlices, err := client.DiscoveryV1().EndpointSlices(service.Namespace).List(context.TODO(), metav1.ListOptions{
// 		LabelSelector: fmt.Sprintf("kubernetes.io/service-name=%s", service.Name),
// 	})
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to get endpointslices: %w", err)
// 	}

// 	var endpointInfos []ServiceEndpointInfo

// 	// Assume single slice for test setup
// 	if len(endpointSlices.Items) > 0 {
// 		slice := endpointSlices.Items[0]
// 		var addresses []string

// 		// Collect all addresses from all endpoints (no ready filter)
// 		for _, endpoint := range slice.Endpoints {
// 			addresses = append(addresses, endpoint.Addresses...)
// 		}

// 		endpointInfos = append(endpointInfos, ServiceEndpointInfo{
// 			Addresses: addresses,
// 			Ports:     slice.Ports,
// 		})
// 	}

// 	return endpointInfos, nil
// }

// // Gomega custom matcher for checking that Service's Endpoints belong to source Cluster
// func HaveSourceClusterEndpoints() types.GomegaMatcher {
// 	return WithTransform(func(service *corev1.Service) bool {
// 		// Get the source service to compare endpoints
// 		sourceService, err := sourceClusterClient.CoreV1().Services(service.Namespace).Get(context.Background(), service.Name, metav1.GetOptions{})
// 		if err != nil {
// 			return false
// 		}

// 		// Get addresses from source cluster
// 		sourceAddresses, err := GetServiceEndpointAddresses(sourceClusterClient, sourceService)
// 		if err != nil || len(sourceAddresses) == 0 {
// 			return false
// 		}

// 		// Get addresses from destination cluster
// 		destAddresses, err := GetServiceEndpointAddresses(destinationClusterClient, service)
// 		if err != nil || len(destAddresses) == 0 {
// 			return false
// 		}

// 		// Compare addresses
// 		return equalStringSlices(sourceAddresses, destAddresses)
// 	}, BeTrue())
// }

// // Helper function to get all endpoint addresses for a service
// func GetServiceEndpointAddresses(client kubernetes.Interface, service *corev1.Service) ([]string, error) {
// 	endpoints, err := GetServiceEndpoints(client, service)
// 	if err != nil {
// 		return nil, err
// 	}

// 	var addresses []string
// 	for _, endpointInfo := range endpoints {
// 		addresses = append(addresses, endpointInfo.Addresses...)
// 	}
// 	return addresses, nil
// }

// // Helper function for slice comparison
// func equalStringSlices(a, b []string) bool {
// 	if len(a) != len(b) {
// 		return false
// 	}

// 	aMap := make(map[string]bool)
// 	for _, addr := range a {
// 		aMap[addr] = true
// 	}

// 	for _, addr := range b {
// 		if !aMap[addr] {
// 			return false
// 		}
// 	}

// 	return true
// }